---
name: workflows:compound
description: Capture learnings from this session to compound your team's knowledge
argument-hint: "[optional: brief context about the fix]"
---

# /compound

Capture learnings from a recently solved problem and write them to Claude Code's native memory system.

## Purpose

Extracts learnings while context is fresh, writing rules to Claude Code's native memory locations:

| Scope | Location | Description |
|-------|----------|-------------|
| Team | `.claude/rules/[category]/` | Shared with team (git-tracked) |
| Personal | `.claude/local/rules/[category]/` | Just you, this project |
| Global | `~/.claude/rules/[category]/` | All your projects |

**Why "compound"?** Each documented learning compounds your team's knowledge. The first time you solve a problem takes research. Capture the learning, and the next occurrence takes minutes. Knowledge compounds.

## Usage

```bash
/workflows:compound                    # Capture learnings from this session
/workflows:compound [brief context]    # Provide additional context hint
```

## 4-Phase Execution

### Phase 1: Extract Learnings (Parallel)

Launch parallel subagents to extract learnings from the session:

**Context Analyzer:**
- Extracts conversation history
- Identifies problem type, symptoms, investigation steps
- Returns: Learning candidates with titles and descriptions

**Solution Extractor:**
- Analyzes what worked and what didn't
- Identifies root cause and fix
- Returns: Solution content with code examples

**Prevention Strategist:**
- Develops prevention strategies
- Creates best practices guidance
- Returns: Prevention/pattern content

### Phase 2: Iterate Learnings (Interactive)

For each extracted learning, use `AskUserQuestion` to let user choose scope:

```
Learning: "N+1 Query Prevention"
Always use includes() when iterating over associations.

→ .claude/rules/database/eager-loading.md

Where should this rule live?

○ Team (Recommended) - Shared with team via .claude/rules/
○ Personal - Just you, this project via .claude/local/rules/
○ Global - All your projects via ~/.claude/rules/
○ Skip - Don't save this learning
```

**Category and filename determined automatically** by Claude based on content. User only chooses scope.

### Phase 3: Missed Anything?

After processing all extracted learnings:

```
Did I miss any learnings from this session?

○ No, we're done - Proceed to write all rules
○ Yes, there's more - Describe what was missed
```

If yes: User describes it, loop back to Phase 2 for that learning.

### Phase 4: Write to Native Locations

Write rule files to selected locations:
- Team: `.claude/rules/[category]/[topic].md`
- Personal: `.claude/local/rules/[category]/[topic].md`
- Global: `~/.claude/rules/[category]/[topic].md`

On first Personal use, automatically:
1. Create `.claude/local/rules/` directory
2. Add `.claude/local/` to `.gitignore`

## What It Captures

- **Problem symptom**: What went wrong
- **Investigation steps**: What didn't work and why
- **Root cause**: Technical explanation
- **Solution**: Working fix with code examples
- **Prevention**: How to avoid in future

## Preconditions

<preconditions enforcement="advisory">
  <check condition="problem_solved">
    Problem has been solved (not in-progress)
  </check>
  <check condition="solution_verified">
    Solution has been verified working
  </check>
  <check condition="non_trivial">
    Non-trivial problem (not simple typo or obvious error)
  </check>
</preconditions>

## Rule File Format

Rules use optional YAML frontmatter for path-scoping:

```markdown
---
paths:
  - "app/models/**/*.rb"
---

# Rule Title

Description of the rule/pattern.

## Why

Technical explanation.

## Wrong

```ruby
# Bad example
```

## Correct

```ruby
# Good example
```
```

## Emergent Categories

Categories are **generated by Claude** based on content. No fixed list - new categories emerge naturally.

**Before creating a new category:**
1. Check existing categories: `ls .claude/rules/`
2. Reuse if learning fits an existing category
3. Create new if no good fit exists

Example categories that might emerge:
- `database` - queries, associations, migrations
- `hotwire` - Turbo, Stimulus patterns
- `testing` - RSpec, factories
- `git` - commits, branches
- `security` - auth, tokens
- (new categories as needed)

## Success Output

```
✓ Learnings captured

Phase 1 - Extracted:
  • N+1 Query Prevention
  • Eager Loading Pattern

Phase 2 - User Selections:
  • N+1 Query Prevention → Team
  • Eager Loading Pattern → Skip

Phase 3 - Missed Anything?: No

Phase 4 - Created:
  • .claude/rules/database/eager-loading.md

These rules will be applied to future sessions working in this project.
```

## The Compounding Philosophy

This creates a compounding knowledge system:

1. First time you solve "N+1 query in brief generation" → Research (30 min)
2. Capture the learning → `.claude/rules/database/eager-loading.md` (5 min)
3. Next time similar issue occurs → Claude already knows (0 min)
4. Knowledge compounds → Team gets smarter

**Each unit of engineering work should make subsequent units of work easier—not harder.**

## Auto-Invoke

<auto_invoke>
  <trigger_phrases>
    - "that worked"
    - "it's fixed"
    - "working now"
    - "problem solved"
  </trigger_phrases>
  <manual_override>
    Use /workflows:compound [context] to capture immediately without auto-detection.
  </manual_override>
</auto_invoke>

## Routes To

`compound-docs` skill

## Related Commands

- `/workflows:plan` - Planning workflow (references captured rules)
- `/workflows:review` - Code review (applies captured rules)
